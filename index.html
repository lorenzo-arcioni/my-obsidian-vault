<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Grafo Obsidian - Tema Dark e Controlli Avanzati</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      height: 100%;
      background-color: #2d2d2d;
      color: #ddd;
      font-family: sans-serif;
    }
    /* SVG a schermo intero con tema dark */
    svg {
      width: 100%;
      height: 100%;
      display: block;
      background-color: #3b3b3b;
    }
    .node {
      fill: #90caf9;
      stroke: #fff;
      stroke-width: 1.5px;
    }
    .link {
      stroke: #bbb;
      stroke-opacity: 0.6;
    }
    text {
      font: 12px sans-serif;
      pointer-events: none;
      fill: #eee;
    }
    /* Pannello di controllo sulla destra */
    #control-panel {
      position: absolute;
      top: 10px;
      right: 10px;
      width: 280px;
      padding: 10px;
      background: rgba(50, 50, 50, 0.95);
      border: 1px solid #555;
      border-radius: 4px;
      box-shadow: 2px 2px 6px rgba(0,0,0,0.5);
    }
    #control-panel h3 {
      margin-top: 0;
      font-size: 16px;
    }
    #control-panel label {
      display: block;
      margin-top: 10px;
      font-size: 14px;
    }
    #control-panel input, #control-panel select {
      width: 100%;
      padding: 4px;
      box-sizing: border-box;
      background: #555;
      border: 1px solid #777;
      color: #ddd;
    }
    #control-panel button {
      margin-top: 10px;
      padding: 8px;
      width: 100%;
      background: #1976d2;
      border: none;
      color: #fff;
      cursor: pointer;
      font-size: 14px;
    }
    #control-panel button:hover {
      background: #1565c0;
    }
    .animation-params {
      margin-top: 10px;
      padding: 10px;
      background: rgba(60, 60, 60, 0.6);
      border-radius: 4px;
    }
    .animation-params h4 {
      margin-top: 0;
      margin-bottom: 10px;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <!-- SVG per il grafo a schermo intero -->
  <svg></svg>
  
  <!-- Pannello di controllo -->
  <div id="control-panel">
    <h3>Parametri Simulazione</h3>
    <label for="linkDistance">Distanza dei Link:</label>
    <input type="number" id="linkDistance" value="150" min="10" max="500">

    <label for="chargeStrength">Forza di Repulsione:</label>
    <input type="number" id="chargeStrength" value="-300" min="-1000" max="0">

    <label for="alphaDecay">Alpha Decay:</label>
    <input type="number" id="alphaDecay" value="0.05" step="0.01" min="0.01" max="0.2">

    <label for="velocityDecay">Velocity Decay:</label>
    <input type="number" id="velocityDecay" value="0.4" step="0.1" min="0.1" max="1">

    <label for="collisionRadius">Raggio di Collisione:</label>
    <input type="number" id="collisionRadius" value="12" min="0" max="50">

    <label for="collisionStrength">Forza di Collisione:</label>
    <input type="number" id="collisionStrength" value="0.7" step="0.1" min="0" max="2">

    <label for="animationType">Tipo di Animazione:</label>
    <select id="animationType">
      <option value="none">Nessuna Animazione</option>
      <option value="random">Random Moving</option>
    </select>

    <!-- Contenitore dinamico per i parametri di animazione -->
    <div id="animation-params-container"></div>

    <button id="restart">Riavvia Simulazione</button>
    <button id="startAnimation">Avvia Simulazione</button>
    <button id="reset">Reset a Stato Iniziale</button>
  </div>

  <!-- Inclusione di D3.js -->
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script>
    // Imposta dimensioni a schermo intero
    const width = window.innerWidth;
    const height = window.innerHeight;

    // Seleziona l'SVG e imposta le dimensioni
    const svg = d3.select("svg")
                  .attr("width", width)
                  .attr("height", height);

    // Gruppo per il grafo (utile per lo zoom)
    const graphGroup = svg.append("g");

    // Variabili globali
    let simulation;
    let originalGraphData;  // conterrà i dati originali caricati
    let animationFrame;     // riferimento al requestAnimationFrame
    let currentAnimation = "none";
    let isAnimating = false;
    const nodeRadius = 10;  // Raggio dei nodi per calcoli di contenimento
    const padding = 20;     // Padding dallo schermo

    // Parametri di animazione per ogni tipo
    const animationParams = {
      none: `
        <div class="animation-params">
          <h4>Nessun parametro disponibile</h4>
          <p>Questa opzione mantiene il grafo statico dopo il posizionamento iniziale.</p>
        </div>
      `,
      random: `
        <div class="animation-params">
          <h4>Parametri Random Moving</h4>
          <label for="randomIntensity">Intensità Movimento:</label>
          <input type="number" id="randomIntensity" value="1" min="0.1" max="5" step="0.1">
          
          <label for="randomSmoothness">Fluidità (minore = più fluido):</label>
          <input type="number" id="randomSmoothness" value="0.02" min="0.001" max="0.1" step="0.001">
        </div>
      `
    };

    // Aggiorna i parametri di animazione in base alla selezione
    function updateAnimationParams() {
      const animationType = document.getElementById("animationType").value;
      document.getElementById("animation-params-container").innerHTML = animationParams[animationType];
      currentAnimation = animationType;

      // Ferma eventuali animazioni in corso
      stopAnimation();
    }

    // Funzione per fermare l'animazione
    function stopAnimation() {
      if (animationFrame) {
        cancelAnimationFrame(animationFrame);
        animationFrame = null;
      }
      isAnimating = false;
    }

    // Inizializza i parametri dell'animazione al caricamento
    updateAnimationParams();

    // Aggiorna i parametri quando cambia la selezione
    document.getElementById("animationType").addEventListener("change", updateAnimationParams);

    // Funzione per inizializzare (o reinizializzare) la simulazione con i dati forniti
    function startSimulation(graphData) {
      // Mappa gli edge nel formato D3
      const links = graphData.edges.map(edge => ({
        source: edge.from,
        target: edge.to
      }));

      // Aggiunge eventuali nodi mancanti referenziati dagli edge
      links.forEach(link => {
        if (!graphData.nodes.some(n => n.id === link.source)) {
          graphData.nodes.push({ id: link.source, label: link.source });
        }
        if (!graphData.nodes.some(n => n.id === link.target)) {
          graphData.nodes.push({ id: link.target, label: link.target });
        }
      });

      // Rimuove vecchi elementi dal gruppo
      graphGroup.selectAll("*").remove();

      // Crea gli elementi per i link
      const link = graphGroup.append("g")
        .attr("class", "links")
        .selectAll("line")
        .data(links)
        .enter().append("line")
          .attr("class", "link");

      // Crea gli elementi per i nodi
      const node = graphGroup.append("g")
        .attr("class", "nodes")
        .selectAll("circle")
        .data(graphData.nodes)
        .enter().append("circle")
          .attr("class", "node")
          .attr("r", nodeRadius)
          .call(drag);

      // Aggiunge le etichette ai nodi
      const label = graphGroup.append("g")
        .attr("class", "labels")
        .selectAll("text")
        .data(graphData.nodes)
        .enter().append("text")
          .attr("dy", -15)
          .attr("text-anchor", "middle")
          .text(d => d.label);

      // Recupera i valori dal pannello di controllo
      const linkDistance = +document.getElementById("linkDistance").value;
      const chargeStrength = +document.getElementById("chargeStrength").value;
      const alphaDecay = +document.getElementById("alphaDecay").value;
      const velocityDecay = +document.getElementById("velocityDecay").value;
      const collisionRadius = +document.getElementById("collisionRadius").value;
      const collisionStrength = +document.getElementById("collisionStrength").value;

      // Crea la simulazione con le forze configurabili
      simulation = d3.forceSimulation(graphData.nodes)
        .force("link", d3.forceLink(links).id(d => d.id).distance(linkDistance))
        .force("charge", d3.forceManyBody().strength(chargeStrength))
        .force("center", d3.forceCenter(width / 2, height / 2))
        .force("collision", d3.forceCollide().radius(collisionRadius).strength(collisionStrength))
        .force("x", d3.forceX(width / 2).strength(0.01))  // Forza leggera verso il centro orizzontale
        .force("y", d3.forceY(height / 2).strength(0.01))  // Forza leggera verso il centro verticale
        .alphaDecay(alphaDecay)
        .velocityDecay(velocityDecay);

      // Aggiorna le posizioni ad ogni tick
      simulation.on("tick", () => {
        // Assicura che i nodi rimangano entro i confini dello schermo
        simulation.nodes().forEach(node => {
          node.x = Math.max(nodeRadius + padding, Math.min(width - nodeRadius - padding, node.x));
          node.y = Math.max(nodeRadius + padding, Math.min(height - nodeRadius - padding, node.y));
        });

        link
          .attr("x1", d => d.source.x)
          .attr("y1", d => d.source.y)
          .attr("x2", d => d.target.x)
          .attr("y2", d => d.target.y);

        node
          .attr("cx", d => d.x)
          .attr("cy", d => d.y);

        label
          .attr("x", d => d.x)
          .attr("y", d => d.y);
      });
    }

    // Funzione per il drag dei nodi
    const drag = d3.drag()
      .on("start", (event, d) => {
        if (!event.active) simulation.alphaTarget(0.3).restart();
        d.fx = d.x;
        d.fy = d.y;
      })
      .on("drag", (event, d) => {
        d.fx = Math.max(nodeRadius + padding, Math.min(width - nodeRadius - padding, event.x));
        d.fy = Math.max(nodeRadius + padding, Math.min(height - nodeRadius - padding, event.y));
      })
      .on("end", (event, d) => {
        if (!event.active) simulation.alphaTarget(0);
        d.fx = null;
        d.fy = null;
      });

    // Abilita lo zoom (rotella del mouse e pan)
    svg.call(d3.zoom()
      .scaleExtent([0.1, 5])
      .on("zoom", (event) => {
        graphGroup.attr("transform", event.transform);
      })
    );

    // Carica il file JSON e salva una copia dei dati originali
    fetch("graph.json")
      .then(response => response.json())
      .then(graphData => {
        // Crea una copia profonda dei dati per il reset
        originalGraphData = JSON.parse(JSON.stringify(graphData));
        startSimulation(graphData);
      })
      .catch(error => console.error("Errore nel caricamento del file JSON:", error));

    // Pulsante per riavviare la simulazione con i parametri nuovi (senza ricreare il grafo)
    document.getElementById("restart").addEventListener("click", () => {
      if (simulation) {
        simulation.force("link").distance(+document.getElementById("linkDistance").value);
        simulation.force("charge").strength(+document.getElementById("chargeStrength").value);
        simulation.force("collision").radius(+document.getElementById("collisionRadius").value)
                .strength(+document.getElementById("collisionStrength").value);
        simulation.alphaDecay(+document.getElementById("alphaDecay").value);
        simulation.velocityDecay(+document.getElementById("velocityDecay").value);
        simulation.alpha(1).restart();
      }
    });

    // Pulsante per resettare la simulazione alla situazione iniziale
    document.getElementById("reset").addEventListener("click", () => {
      if (originalGraphData) {
        // Ferma eventuali animazioni in corso
        stopAnimation();
        
        // Crea una nuova copia dei dati originali per evitare modifiche in-place
        const resetData = JSON.parse(JSON.stringify(originalGraphData));
        startSimulation(resetData);
      }
    });

    // Funzione per l'animazione random dei nodi (fluida con requestAnimationFrame)
    function animateRandomMovement() {
      if (!simulation || !isAnimating) return;
      
      // Intensità del movimento casuale
      const intensity = +document.getElementById("randomIntensity").value;
      const smoothness = +document.getElementById("randomSmoothness").value;
      
      // Assegna velocità casuali iniziali ai nodi se necessario
      simulation.nodes().forEach(node => {
        // Inizializza le velocità se non esistono
        if (!node.vx) node.vx = (Math.random() - 0.5) * intensity;
        if (!node.vy) node.vy = (Math.random() - 0.5) * intensity;
        
        // Aggiorna le velocità con leggere variazioni casuali per fluidità
        node.vx += (Math.random() - 0.5) * smoothness * intensity;
        node.vy += (Math.random() - 0.5) * smoothness * intensity;
        
        // Limita la velocità massima
        const maxSpeed = intensity * 2;
        const speed = Math.sqrt(node.vx * node.vx + node.vy * node.vy);
        if (speed > maxSpeed) {
          node.vx = (node.vx / speed) * maxSpeed;
          node.vy = (node.vy / speed) * maxSpeed;
        }
        
        // Muovi il nodo in base alla sua velocità (solo se non è fissato)
        if (!node.fx && !node.fy) {
          node.x += node.vx;
          node.y += node.vy;
          
          // Rimbalza dai bordi dello schermo
          if (node.x < nodeRadius + padding) {
            node.x = nodeRadius + padding;
            node.vx = Math.abs(node.vx);
          } else if (node.x > width - nodeRadius - padding) {
            node.x = width - nodeRadius - padding;
            node.vx = -Math.abs(node.vx);
          }
          
          if (node.y < nodeRadius + padding) {
            node.y = nodeRadius + padding;
            node.vy = Math.abs(node.vy);
          } else if (node.y > height - nodeRadius - padding) {
            node.y = height - nodeRadius - padding;
            node.vy = -Math.abs(node.vy);
          }
        }
      });
      
      // Forza un aggiornamento della visualizzazione
      simulation.alpha(0.3).restart();
      
      // Continua l'animazione
      animationFrame = requestAnimationFrame(animateRandomMovement);
    }

    // Pulsante per avviare l'animazione
    document.getElementById("startAnimation").addEventListener("click", () => {
      // Ferma eventuali animazioni in corso
      stopAnimation();
      
      // Avvia l'animazione appropriata se non è "nessuna"
      if (currentAnimation === "random") {
        isAnimating = true;
        animationFrame = requestAnimationFrame(animateRandomMovement);
      }
    });

    // Ferma l'animazione quando la finestra perde il focus
    window.addEventListener("blur", stopAnimation);
    
    // Gestisce il ridimensionamento della finestra
    window.addEventListener("resize", () => {
      const newWidth = window.innerWidth;
      const newHeight = window.innerHeight;
      
      svg.attr("width", newWidth).attr("height", newHeight);
      
      // Aggiorna le forze centrali
      if (simulation) {
        simulation.force("center").x(newWidth / 2).y(newHeight / 2);
        simulation.force("x").x(newWidth / 2);
        simulation.force("y").y(newHeight / 2);
        simulation.alpha(0.3).restart();
      }
    });
  </script>
</body>
</html>
